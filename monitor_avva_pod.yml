---
- name: Monitor AVVA pod logs & restart if required
  hosts: localhost
  connection: local
  gather_facts: no

  vars:
    namespace: default
    pod_label: "app=avva-app"
    max_restarts: 3
    wait_ready_timeout: 120
    log_tail_lines: 200
    failure_regex: "(?i)(error|failed|exception|panic|traceback)"

    ticket_on_failure: true
    ticket_api_url: "https://ascendiondigitalsolutionsdemo1.service-now.com/api/now/table/incident"

    # These come from AWX credential mapping
    ticket_auth_user: "{{ sn_user }}"
    ticket_auth_pass: "{{ sn_pass }}"

    ticket_payload:
      short_description: "AVVA pod failed after restarts"
      description: |
        Pod label: {{ pod_label }}
        Namespace: {{ namespace }}
        Attempts: {{ max_restarts }}
        Observed logs: "{{ last_failure_excerpt | default('n/a') }}"

  tasks:

    - name: Find pod name matching label
      command: >
        kubectl get pods -n {{ namespace }} -l "{{ pod_label }}"
        -o jsonpath='{.items[0].metadata.name}'
      register: pod_get
      failed_when: pod_get.stdout == ""

    - set_fact:
        pod_name: "{{ pod_get.stdout | trim }}"

    - name: Fetch latest logs
      command: kubectl logs {{ pod_name }} -n {{ namespace }} --tail={{ log_tail_lines }}
      register: pod_logs
      failed_when: false

    - set_fact:
        failed_match: "{{ (pod_logs.stdout is search(failure_regex)) | bool }}"
        last_failure_excerpt: "{{ pod_logs.stdout[:400] }}"

    - name: Exit play if pod is healthy
      meta: end_play
      when: failed_match == false

    ###############################################################
    # Restart loop â€” FIXED for AWX using with_sequence
    ###############################################################
    - name: Restart pod attempts
      block:

        - name: Delete pod to restart it
          command: kubectl delete pod {{ pod_name }} -n {{ namespace }} --wait=false
          failed_when: false

        - name: Wait for new pod to be ready
          command: >
            kubectl wait --for=condition=ready pod -l "{{ pod_label }}"
            -n {{ namespace }} --timeout={{ wait_ready_timeout }}s
          register: wait_res
          failed_when: wait_res.rc != 0

        - name: Get new pod name
          command: >
            kubectl get pods -n {{ namespace }} -l "{{ pod_label }}"
            -o jsonpath='{.items[0].metadata.name}'
          register: newpod

        - set_fact:
            pod_name: "{{ newpod.stdout | trim }}"

        - pause:
            seconds: 5

        - name: Check logs after restart
          command: kubectl logs {{ pod_name }} -n {{ namespace }} --tail={{ log_tail_lines }}
          register: log_after

        - set_fact:
            failed_match_after: "{{ (log_after.stdout is search(failure_regex)) | bool }}"
            last_failure_excerpt: "{{ log_after.stdout[:400] }}"

        - meta: end_loop
          when: failed_match_after == false

      with_sequence: start=1 end="{{ max_restarts }}"

    ###############################################################
    # Final result and ticket creation
    ###############################################################
    - set_fact:
        final_failed: "{{ failed_match_after | default(true) }}"

    - name: Create ServiceNow ticket if failure continues
      when: final_failed and ticket_on_failure
      uri:
        url: "{{ ticket_api_url }}"
        method: POST
        user: "{{ ticket_auth_user }}"
        password: "{{ ticket_auth_pass }}"
        force_basic_auth: yes
        status_code: 200,201
        headers:
          Content-Type: "application/json"
        body: "{{ ticket_payload | to_json }}"
      register: ticket_result

    - debug:
        var: ticket_result.json
      when: final_failed and ticket_on_failure

    - debug:
        msg: "Monitoring finished. Final failure = {{ final_failed }} | pod = {{ pod_name }}"
